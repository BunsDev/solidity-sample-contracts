/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export interface ExtendedOperationsInterface extends utils.Interface {
  functions: {
    "Add(bytes3,uint256,uint256)": FunctionFragment;
    "And(bytes3,uint256,uint256)": FunctionFragment;
    "Decrypt(bytes1,uint256)": FunctionFragment;
    "Div(bytes3,uint256,uint256)": FunctionFragment;
    "Eq(bytes3,uint256,uint256)": FunctionFragment;
    "Ge(bytes3,uint256,uint256)": FunctionFragment;
    "GetUserKey(bytes)": FunctionFragment;
    "Gt(bytes3,uint256,uint256)": FunctionFragment;
    "Le(bytes3,uint256,uint256)": FunctionFragment;
    "Lt(bytes3,uint256,uint256)": FunctionFragment;
    "Max(bytes3,uint256,uint256)": FunctionFragment;
    "Min(bytes3,uint256,uint256)": FunctionFragment;
    "Mul(bytes3,uint256,uint256)": FunctionFragment;
    "Mux(bytes3,uint256,uint256,uint256)": FunctionFragment;
    "Ne(bytes3,uint256,uint256)": FunctionFragment;
    "Not(bytes1,uint256)": FunctionFragment;
    "OffBoard(bytes1,uint256)": FunctionFragment;
    "OffBoardToUser(bytes1,uint256,bytes)": FunctionFragment;
    "OnBoard(bytes1,uint256)": FunctionFragment;
    "Or(bytes3,uint256,uint256)": FunctionFragment;
    "Rand(bytes1)": FunctionFragment;
    "RandBoundedBits(bytes1,uint8)": FunctionFragment;
    "Rem(bytes3,uint256,uint256)": FunctionFragment;
    "SetPublic(bytes1,uint256)": FunctionFragment;
    "Shl(bytes3,uint256,uint256)": FunctionFragment;
    "Shr(bytes3,uint256,uint256)": FunctionFragment;
    "Sub(bytes3,uint256,uint256)": FunctionFragment;
    "Transfer(bytes4,uint256,uint256,uint256)": FunctionFragment;
    "TransferWithAllowance(bytes4,uint256,uint256,uint256,uint256)": FunctionFragment;
    "ValidateCiphertext(bytes1,uint256,bytes)": FunctionFragment;
    "Xor(bytes3,uint256,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "Add"
      | "And"
      | "Decrypt"
      | "Div"
      | "Eq"
      | "Ge"
      | "GetUserKey"
      | "Gt"
      | "Le"
      | "Lt"
      | "Max"
      | "Min"
      | "Mul"
      | "Mux"
      | "Ne"
      | "Not"
      | "OffBoard"
      | "OffBoardToUser"
      | "OnBoard"
      | "Or"
      | "Rand"
      | "RandBoundedBits"
      | "Rem"
      | "SetPublic"
      | "Shl"
      | "Shr"
      | "Sub"
      | "Transfer"
      | "TransferWithAllowance"
      | "ValidateCiphertext"
      | "Xor"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "Add",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "And",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Decrypt",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "Div",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Eq",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Ge",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "GetUserKey",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "Gt",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Le",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Lt",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Max",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Min",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Mul",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Mux",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Ne",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Not",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "OffBoard",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "OffBoardToUser",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "OnBoard",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "Or",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Rand",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "RandBoundedBits",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "Rem",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "SetPublic",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "Shl",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Shr",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Sub",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Transfer",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "TransferWithAllowance",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "ValidateCiphertext",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "Xor",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(functionFragment: "Add", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "And", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Decrypt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Div", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Eq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Ge", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "GetUserKey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Gt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Le", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Lt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Max", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Min", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Mul", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Mux", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Ne", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Not", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "OffBoard", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "OffBoardToUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "OnBoard", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Or", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Rand", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "RandBoundedBits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "Rem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "SetPublic", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Shl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Shr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Sub", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "TransferWithAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ValidateCiphertext",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "Xor", data: BytesLike): Result;

  events: {};
}

export interface ExtendedOperations extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ExtendedOperationsInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    Add(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    And(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Decrypt(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Div(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Eq(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Ge(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    GetUserKey(
      signedEK: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { encryptedKey: string }>;

    Gt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Le(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Lt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Max(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Min(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Mul(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Mux(
      metaData: PromiseOrValue<BytesLike>,
      bit: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Ne(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Not(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    OffBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    OffBoardToUser(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      addr: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    OnBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Or(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Rand(
      metaData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    RandBoundedBits(
      metaData: PromiseOrValue<BytesLike>,
      numBits: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Rem(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    SetPublic(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Shl(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Shr(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Sub(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Transfer(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    TransferWithAllowance(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      allowance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    ValidateCiphertext(
      metaData: PromiseOrValue<BytesLike>,
      ciphertext: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    Xor(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  Add(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  And(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Decrypt(
    metaData: PromiseOrValue<BytesLike>,
    a: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Div(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Eq(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Ge(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  GetUserKey(
    signedEK: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  Gt(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Le(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Lt(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Max(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Min(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Mul(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Mux(
    metaData: PromiseOrValue<BytesLike>,
    bit: PromiseOrValue<BigNumberish>,
    a: PromiseOrValue<BigNumberish>,
    b: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Ne(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Not(
    metaData: PromiseOrValue<BytesLike>,
    a: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  OffBoard(
    metaData: PromiseOrValue<BytesLike>,
    ct: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  OffBoardToUser(
    metaData: PromiseOrValue<BytesLike>,
    ct: PromiseOrValue<BigNumberish>,
    addr: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  OnBoard(
    metaData: PromiseOrValue<BytesLike>,
    ct: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Or(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Rand(
    metaData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  RandBoundedBits(
    metaData: PromiseOrValue<BytesLike>,
    numBits: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Rem(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  SetPublic(
    metaData: PromiseOrValue<BytesLike>,
    ct: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Shl(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Shr(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Sub(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Transfer(
    metaData: PromiseOrValue<BytesLike>,
    a: PromiseOrValue<BigNumberish>,
    b: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  TransferWithAllowance(
    metaData: PromiseOrValue<BytesLike>,
    a: PromiseOrValue<BigNumberish>,
    b: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    allowance: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  ValidateCiphertext(
    metaData: PromiseOrValue<BytesLike>,
    ciphertext: PromiseOrValue<BigNumberish>,
    signature: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  Xor(
    metaData: PromiseOrValue<BytesLike>,
    lhs: PromiseOrValue<BigNumberish>,
    rhs: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    Add(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    And(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Decrypt(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Div(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Eq(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Ge(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    GetUserKey(
      signedEK: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    Gt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Le(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Lt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Max(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Min(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Mul(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Mux(
      metaData: PromiseOrValue<BytesLike>,
      bit: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Ne(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Not(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    OffBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    OffBoardToUser(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      addr: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    OnBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Or(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Rand(
      metaData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    RandBoundedBits(
      metaData: PromiseOrValue<BytesLike>,
      numBits: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Rem(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    SetPublic(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Shl(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Shr(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Sub(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Transfer(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        new_a: BigNumber;
        new_b: BigNumber;
        res: BigNumber;
      }
    >;

    TransferWithAllowance(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      allowance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        new_a: BigNumber;
        new_b: BigNumber;
        res: BigNumber;
        new_allowance: BigNumber;
      }
    >;

    ValidateCiphertext(
      metaData: PromiseOrValue<BytesLike>,
      ciphertext: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Xor(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    Add(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    And(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Decrypt(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Div(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Eq(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Ge(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    GetUserKey(
      signedEK: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    Gt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Le(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Lt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Max(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Min(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Mul(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Mux(
      metaData: PromiseOrValue<BytesLike>,
      bit: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Ne(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Not(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    OffBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    OffBoardToUser(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      addr: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    OnBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Or(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Rand(
      metaData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    RandBoundedBits(
      metaData: PromiseOrValue<BytesLike>,
      numBits: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Rem(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    SetPublic(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Shl(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Shr(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Sub(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Transfer(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    TransferWithAllowance(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      allowance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    ValidateCiphertext(
      metaData: PromiseOrValue<BytesLike>,
      ciphertext: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    Xor(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    Add(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    And(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Decrypt(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Div(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Eq(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Ge(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    GetUserKey(
      signedEK: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    Gt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Le(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Lt(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Max(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Min(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Mul(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Mux(
      metaData: PromiseOrValue<BytesLike>,
      bit: PromiseOrValue<BigNumberish>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Ne(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Not(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    OffBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    OffBoardToUser(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      addr: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    OnBoard(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Or(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Rand(
      metaData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    RandBoundedBits(
      metaData: PromiseOrValue<BytesLike>,
      numBits: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Rem(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    SetPublic(
      metaData: PromiseOrValue<BytesLike>,
      ct: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Shl(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Shr(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Sub(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Transfer(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    TransferWithAllowance(
      metaData: PromiseOrValue<BytesLike>,
      a: PromiseOrValue<BigNumberish>,
      b: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      allowance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    ValidateCiphertext(
      metaData: PromiseOrValue<BytesLike>,
      ciphertext: PromiseOrValue<BigNumberish>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    Xor(
      metaData: PromiseOrValue<BytesLike>,
      lhs: PromiseOrValue<BigNumberish>,
      rhs: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
